(do

(set *uvarn* -1)

(set concat
  (fn (a1 a2)
    (. a1 'concat a2)))

(set slice
  (fn (xs i)
    (. xs 'slice i)))

(set mac
  (macro (name args . body)
    (arr 'set name (concat (arr 'macro args) body))))

(mac def (name args . body)
  (arr 'set name (concat (arr 'fn args) body)))

(def uvar ()
  (set *uvarn* (+ *uvarn* 1))
  (+ "_g" *uvarn*))

(mac if args
  (? (empty args)
     false
     (? (id (length args) 1)
        (0 args)
        (arr '? (0 args) (1 args) (concat (arr 'if) (slice args 2))))))

(def log (x)
  (. console 'log x))

(set a 42)
(log a)

(set b 99)
(set c a)
(log c)

(log
 (? 0 b c))

(log
 (do a b c))

(log
 (do 100))

(log
 (+ b c))

(def add (x y)
  (+ 1 2)
  (+ x y))

(log
 (add 3 4))

(set a1 [1 2 3])
(log a1)
(log
 (0 a1))
(0 a1 10)
(a1 2 100)
(log a1)

(log
 ([97 98 99] 1))

(set dict {a 1 b 2})
(log
 ('b dict))

('b dict 22)

(log
 (dict 'b))

(dict 'b 2)

(log
 ('b dict))

(def length (x)
  (. x '-length))

(def first (x)
  (0 x))

(def rest (x)
  (slice x 1))

(def copy (x)
  (slice x 0))

(def empty (x)
  (id (length x) 0))

(def not (x)
  (id x false))

(log
 (first a1))

(log
 (rest a1))

(log
 (empty a1))

(log
 (not (id (length (copy a1)) 2)))

(log
 (type null))

(mac double (x)
  (arr 'add x x))

(log
 (double 3))

(log
 (concat [1 2 3] [4 5 6]))

(mac let (parms val . body)
  (arr (concat (arr 'fn (arr parms)) body) val))

(log (let x 9 (+ x 2)))

(log (if))

(log (if (+ 1 2)))

(log
 (if false b
     false 999
     (+ a 100)))

(log "hello")

(log (. "hello" 'toUpperCase))
(log (length "hello"))

(log (. "[[[hello]]]" 'replace (new RegExp "\[" "g") "("))

(log ((fn (x . y) y) 1 2 3))

(def array (x)
  (id (type x) "array"))

(def atom (x)
  (not (array x)))

(def bquote (x)
  (if (atom x)
        (quote x)
      (id (0 x) 'comma)
        (1 x)
      (and (array (0 x)) (id (0 (0 x)) 'comma-at))
        (concat (1 (0 x)) (bquote (slice x 1)))
        (concat (arr (bquote (0 x))) (bquote (slice x 1)))))

(log (uvar))
(log (uvar))

)
